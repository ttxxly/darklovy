在 java 多线程编程中经常说的就是：“原子操作（atomic operation） 不需要 synchronized”。原子操作指的是不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch（切换到另一个线程）。

#### 定义

如果这个操作所处的层（layer）的更高层不能发现其内部实现与结构，那么这个操作就是一个原子操作。

原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体是原子性的核心特征。

#### CAS 原理

CAS（Compare And Set），其作用是对某一个变量进行原子化的更新操作。

该算法的思想是： 

```
CAS(v, e , u)
	- v : 表示要更新的变量
	- e : 表示变量的预期值
	- u : 表示变量的新值
	
当且仅当 v 的实际值等于 e 值时， 才会将 v 的值设为 u 
如果 v 值和 e 值不同，则说明已经有其他线程做了更新，那么当前线程什么都不做，即更新失败。
CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。
当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。
失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。
基于这样的原理，CAS操作即时没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。
```

**注:CAS其底层是通过CPU的1条指令来完成3个步骤，因此其本身是一个原子性操作，不存在其执行某一个步骤的时候而被中断的可能。** 

#### 使用原子操作的好处

* 性能角度：它执行多次的所消耗的时间远远小于由于线程所挂起到恢复所消耗的时间，因此无锁的CAS操作在性能上要比同步锁高很多。

* 业务需求：业务本身的需求上，无锁机制本身就可以满足我们绝不多数的需求，并且在性能上也可以大大的进行提升。

  例子：我们使用的版本控制工具与之其实非常的相似，如果使用锁来同步，其实就意味着只能同时一个人对该文件进行修改，此时其他人就无法操作文件，如果生活中真正遇到这样的情况我们一定会觉得非常不方便，而现实中我们其实并不是这样，我们大家都可以修改这个文件，只是谁提交的早，那么他就把他的代码成功提交的版本控制服务器上，其实这一步就对应着一个原子操作，而后操作的人往往却因为冲突而导致提交失败，此时他必须重新更新代码进行再次修改，重新提交。

#### 参考资料

---

1. [百度百科-原子操作](https://baike.baidu.com/item/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C)
2. [深入分析java中的原子操作](http://www.jianshu.com/p/9ff426a784ad) 

