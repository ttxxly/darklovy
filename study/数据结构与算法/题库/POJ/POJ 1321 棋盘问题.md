链接： http://poj.org/problem?id=1321

## 棋盘问题

#### 关键词：DFS

### Description

在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。

### Input

输入含有多组测试数据。 
每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n <= 8 , k <= n 
当为-1 -1时表示输入结束。 
随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。

### Output

对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C < 2^31）。

### SampleInput

```
2 1
#.
.#
4 4
...#
..#.
.#..
#...
-1 -1
```

### SampleOutput

```
2
1
```

### Analyze

DFS 搜索， 可以直接看代码。。。

### Code

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

int n, k, ans;

char map[10][10];
bool vis[10];

void DFS(int cur, int cnt)
{
    if(n-cur < k-cnt)//所描述的含义是：我本来还要放置cnt个棋子，然而可以放置的位置已经不够了o
        return;
    if(cnt > k)//表示的含义就是我已经放置k个棋子咯，满足条件，这个方案可行，可行方案数加1
    {
        ans++;
        return;
    }
    for(int j=1; j<=n; j++)
    {
        if(map[cur][j]=='#' && !vis[j])
        {
            vis[j] = true;
            DFS(cur+1, cnt+1);
            vis[j] = false;
        }
    }
    DFS(cur+1, cnt);//表示这一行我们不放置棋子，嘿嘿。
}
int main()
{
    while(scanf("%d%d", &n,&k) != EOF)
    {
        memset(vis, false, sizeof(vis));
        ans = 0;
        getchar();
        if(n==-1 && k==-1)
            break;
        for(int i=1; i<=n; i++)
            gets(map[i] + 1);

//        for(int i=1; i<=n; i++)
//            puts(map[i]+1);
        DFS(1,1);
        printf("%d\n", ans);
    }

    return 0;
}

```