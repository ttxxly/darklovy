[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=2089)

## 不要62

Time Limit: 1000/1000 MS (Java/Others)  
Memory Limit: 32768/32768 K (Java/Others)  
Total Submission(s): 42877  
Accepted Submission(s): 15685


### Problem Description

杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。

不吉利的数字为所有含有4或62的号码。例如：  
62315 73418 88914  
都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。

你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。
 

### Input

输入的都是整数对n、m（0 < n ≤ m <  1000000），如果遇到都是0的整数对，则输入结束。
 
### Output

对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。
 
### Sample Input

```
1 100
0 0
```

### Sample Output

```
80
```

### Author

qianneng
 
### Source

迎接新学期——超级Easy版热身赛

### 题目大意

给定区间 [n, m] ， 求在 n 到 m 中不含有 "62" 或 "4" 的数的个数。
如 62315 包含 62 ， 88914 包含 4 ， 这两个数都是不合法的； 61152 这个数 62 不是连在一起的，所以是可以的。

数据范围是 ： 0 < n ≤ m < 1000000

### Analyze

dp[i][j] ： 表示首位是数字j的i位数有多少是合法的。

j==4 时： dp[i][j] = 0  

j!=4 时：`$dp[i][j] = \sum_{k=0}^{9} (dp[i-1][k])$` (注意62的问题，k为2的时候，j就不能为6)

对于 335：

1. [0, 300) 范围内

```
dp[3][0]: 000 - 099
dp[3][1]: 100 - 199
dp[3][2]: 200 - 299
```

2. [300, 330) 范围内

```
dp[2][0]: 300 - 309
dp[2][1]: 310 - 319
dp[2][2]: 320 - 329
```

3. [330, 336) 范围内

```
dp[1][0]: 330
dp[1][1]: 331
dp[1][2]: 332
dp[1][3]: 333
dp[1][4]: 334
dp[1][5]: 335
```

到此 [0, 335] 中素有满足条件的数都已求出。

写到这里其实还有个问题：那就是62 和 4 的问题。

再看例子： 77432

1. [0, 70000)

```
dp[5][0]: 00000 - 09999
dp[5][1]: 10000 - 19999
dp[5][2]: 20000 - 29999
dp[5][3]: 30000 - 39999
dp[5][4]: 40000 - 49999
dp[5][5]: 50000 - 59999
dp[5][6]: 60000 - 69999
```

2. [70000, 77000)

```
dp[4][0]: 70000 - 70999
dp[4][1]: 71000 - 71999
dp[4][2]: 72000 - 72999
dp[4][3]: 73000 - 73999
dp[4][4]: 74000 - 74999
dp[4][5]: 75000 - 75999
dp[4][6]: 76000 - 76999
```

3. [77000, 77400)

```
dp[3][0]: 77000 - 77099
dp[3][1]: 77100 - 77199
dp[3][2]: 77200 - 77299
dp[3[[3]: 77300 - 77399
```

4. [77400, 77430) 数字中都带有四

```
dp[2][0]: 77400 - 77409
dp[2][1]: 77410 - 77419
dp[2][2]: 77420 - 77429
```

5. [77430, 77433) 数字中都带有四

```
dp[1][0]: 77430
dp[1][1]: 77431
dp[1][2]: 77432
```


### Code

```c++
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

int dp[10][10]; //dp[i][j] 表示i位数，首位是j的数字有多少符合要求的。
int d[10];

void init() //预处理dp[i][j]
{
    dp[0][0] = 1;
    for (int i = 1; i <= 7; i++)
        for (int j = 0; j <= 9; j++)
            for (int k = 0; k <= 9; k++)
                if (j != 4 && !(j == 6 && k == 2))
                    dp[i][j] += dp[i - 1][k];
}

int solve(int n)
{
    int ans = 0;
    int len = 0;
    while (n)
    {
        len++;
        d[len] = n % 10;
        n /= 10;
    }
    d[len+1] = 0;
    for (int i = len; i >= 1; i--)
    {
        for (int j = 0; j < d[i]; j++)
        {
            if (d[i + 1] != 6 || j != 2)
                ans += dp[i][j];    //看上面解析，满足条件就加
        }
        if (d[i] == 4 || (d[i + 1] == 6 && d[i] == 2))
            break;
    }
    return ans;
}

int main()
{
    int m, n;
    init();
    while (scanf("%d%d", &m, &n) == 2)
    {
        if (n == 0 && m == 0) break;
        printf("%d\n", solve(n + 1) - solve(m));
    }
    return 0;
}


```

