[题目链接]( http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=690&pid=1001)

## 2016百度之星第一题

### Description

度熊手上有一本字典存储了大量的单词，有一次，他把所有单词组成了一个很长很长的字符串。现在麻烦来了，他忘记了原来的字符串都是什么，神奇的是他竟然记得原来那些字符串的哈希值。一个字符串的哈希值，由以下公式计算得到：

```math
H(s) = \prod_{i=1}^{i<len(s)} (S_i - 28)(mod 9973)
```


`$S_i$` 代表 S[i] 字符的 ASCII 码。  
请帮助度熊计算大字符串中任意一段的哈希值是多少。

### Input

多组测试数据，每组测试数据第一行是一个正整数N，代表询问的次数，第二行一个字符串，代表题目中的大字符串，接下来N行，每行包含两个正整数a和b，代表询问的起始位置以及终止位置。

1 ≤ N ≤ 1,000

1 ≤ len(string) ≤ 100,000

1 ≤ a,b ≤ len(string)

### Output

对于每一个询问，输出一个整数值，代表大字符串从 a 位到 b 位的子串的哈希值。

### SampleInput

```
2
ACMlove2015
1 11
8 10
1
testMessage
1 1
```

### SampleOutput

```
6891
9240
88
```

### Hint

### Source

### Analyze

dp[i]表示从1到i的乘积，那么对于区间【a,b】就可以用dp[b] / dp[a] (b>=a),到哦这一步我们就可以用到乘法逆元咯。a/b%p  =  (a * (b^p-2)) % p， 而b^(p-2)我们可以用到快速幂。


### Code

```
#include<stdio.h>  
#include<string.h>  
#include<string>  
#include<iostream>  
#include<algorithm>  
using namespace std;  
string s;  
long long dp[100010];  
  
long long quickmod(long long a,long long b)  
{  
    long long sum=1;  
    while(b)  
    {  
        if(b&1)  
            sum=(sum*a)%9973;  
        b>>=1;  
        a=(a*a)%9973;  
    }  
    return sum;  
}  
int main()  
{  
    long long n;  
  
    while(scanf("%I64d", &n) != EOF)  
    {  
        cin>>s;  
        dp[0] = 1;  
        for(long long i=1; i<=s.size(); i++)  
            dp[i] = (dp[i-1] * (s[i-1]-28) ) % 9973;  
        long long a, b;  
        for(long long i=0; i<n; i++)  
        {  
            scanf("%I64d%I64d", &a, &b);  
            if(a > b)  
                swap(a,b);  
            printf("%I64d\n", (dp[b]*(quickmod(dp[a-1],9971)%9973))%9973);  
        }  
    }  
  
    return 0;  
} 
```