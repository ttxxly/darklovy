冒泡排序算法是一种简单的排序算法，本文将介绍冒泡排序的原理和实现。

#### 实现原理

```
原理：相邻的数字之间两两进行比较，按照从小到大的顺序或者从大到小的顺序进行交换。

模拟：将数组 6 2 4 1 5 9按照从小到大的顺序排列

1. 两两进行比较
	交换前状态：6 2 4 1 5 9
	交换后状态：2 4 1 5 6 9
	注意：
		自己在草稿纸上演算下，我省略了很多步骤，
		这个结果是将数组中的元素全部进行了两两交换后得出的。
2. 我们可以看到的是两两进行比较，实际上是将当前数组中最大的元素排在最后一位（从小到大顺序）
	这意味着在下次的排序中，我们可以不用再对最后一位进行排序了，它已经是有序的了。
	交换前状态：2 4 1 5 6 9
	交换后状态：2 1 4 5 6 9
	对于数组 2 4 1 5 6 来说，将当前数组最大值6排在了最后一位
3. 同理 
	交换前状态：2 1 4 5 6 9
	交换后状态：1 2 4 5 6 9
4. 数组已经是有序的了
5. 数组有序

注意：
	观察上面的步骤，我们可以发现的是：每一趟排序是将最大值放在最后一位（从小到大的顺序）
	所以如果数组元素个数为n，那么经过 n-1 趟排序之后，该数组一定是有序的。
	
下面将上述的步骤转化为 伪代码实现：
    function bubble_sort (array, length) {
        var i, j;
        for(i from 0 to length-1){
            for(j from 0 to length-1-i){
                if (array[j] > array[j+1])
                    swap(array[j], array[j+1])
            }
        }
    }
    解析：
    	外层 for 循环表示需要经过的趟数（length-1）
    	内层 for 循环表示当前我们需要排序的数组，从下标为0的元素开始比较
    		i = 0 -> j的范围是 [0, length-1] 就是当前需要比较的数组
    		i = 1 -> j的范围是 [0, length-1-1] 因为上一趟已经将最大值放在最后一位。
    		....
```

#### 代码实现

```
#include <stdio.h>

int main()
{
    int arr[6] = {6,2,4,1,5,9};
    int length = sizeof(arr) / sizeof(arr[0]);
    for(int i=0; i<length-1; i++)
    {
        for(int j=0; j<length-1-i; j++)
        {
            if(arr[j] > arr[j+1])
            {
                arr[j] = arr[j] + arr[j+1];
                arr[j+1] = arr[j] - arr[j+1];
                arr[j] = arr[j] - arr[j+1];
            }
        }
    }
    for(int i=0; i<length; i++)
        printf("%d ", arr[i]);

    return 0;
}
```

